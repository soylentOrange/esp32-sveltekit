{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ESP32 SvelteKit Lightswitch","text":"<p>A simple ESP32 based IoT project with a feature-rich, beautiful, and responsive front-end build with Sveltekit, TailwindCSS and DaisyUI. This project was generated from the great ESP32-sveltekit template by elims.</p> <p>Info</p> <p>This project is just a bare minimum functional example. It is indended as a starting point for further projects in need of a rich web UI.</p>"},{"location":"#hardware","title":"Hardware","text":"<p>Tested on wemos_d1_mini32 board. The board is discontinued by Wemos, but several clones are being offered with very low pricetags.</p> <p>Info</p> <p>The onboard-LED is connected to GPIO-02.</p>"},{"location":"#visit-the-esp32-sveltekit-project-site","title":"Visit the ESP32-sveltekit Project Site","text":"<p>See how to get started with your own project at: https://theelims.github.io/ESP32-sveltekit/.</p>"},{"location":"#license","title":"License","text":"<p>ESP32 SvelteKit Lightswitch is distributed with two licenses for different sections of the code. The back end code inherits the GNU LESSER GENERAL PUBLIC LICENSE Version 3 and is therefore distributed with said license. The front end code is distributed under the MIT License. See the LICENSE for a full text of both licenses.</p>"},{"location":"customproject/","title":"Developing with the Framework","text":"<p>interface/package.json interface/package-lock.json interface/static/manifest.json</p> <p>Installing Node.js with nvm nvm (Node Version Manager) allows you to manage multiple Node.js versions. It\u2019s especially useful for projects requiring different Node.js versions.</p> <p>Installing nvm  see: https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating</p> <p>You can list available versions using ls-remote:</p> <p>nvm ls-remote</p> <p>To install a specific version of node:</p> <p>nvm install v20.18.0 # or 16.3.0, 12.22.1, etc</p> <p>Using nvm to Install Node.js Install the latest Node.js version: nvm install node To install a specific Node.js version, use: nvm install [version] Switch between installed Node.js versions with: nvm use [version]</p> <p>The back end is a set of REST endpoints hosted by a PsychicHttp instance. The 'lib/framework' directory contains the majority of the back end code. The framework contains a number of useful utility classes which you can use when extending it. The project also comes with a demo project to give you some help getting started.</p> <p>The framework's source is split up by feature, for example WiFiScanner.h implements the end points for scanning for available networks where as WiFiSettingsService.h handles configuring the WiFi settings and managing the WiFi connection.</p>"},{"location":"customproject/#initializing-the-framework","title":"Initializing the framework","text":"<p>The 'src/main.cpp' file constructs the web server and initializes the framework. You can add endpoints to the server here to support your IoT project. The main loop is also accessible so you can run your own code easily.</p> <p>The following code creates the web server and esp32sveltekit framework:</p> <pre><code>PsychicHttpServer server;\nESP32SvelteKit esp32sveltekit(&amp;server, 120);\n</code></pre> <p>ESP32SvelteKit is instantiated with a reference to the server and a number of HTTP endpoints. The underlying ESP-IDF HTTP Server statically allocates memory for each endpoint and needs to know how many there are. Best is to inspect your WWWData.h file for the number of Endpoints from SvelteKit (currently 60), the framework itself has 37 endpoints, and Lighstate Demo has 7 endpoints. Each <code>_server.on()</code> counts as an endpoint. Don't forget to add a couple of spare, just in case. Each HttpEndpoint adds 2 endpoints, if CORS is enabled it adds an other endpoint for the CORS preflight request.</p> <p>Now in the <code>setup()</code> function the initialization is performed:</p> <pre><code>void setup() {\n  // start serial and filesystem\n  Serial.begin(SERIAL_BAUD_RATE);\n\n  // start the framework and demo project\n  esp32sveltekit.begin();\n}\n</code></pre> <p><code>server.begin()</code> is called by ESP32-SvelteKit, as the start-up sequence is crucial.</p>"},{"location":"customproject/#stateful-service","title":"Stateful Service","text":"<p>The framework promotes a modular design and exposes features you may re-use to speed up the development of your project. Where possible it is recommended that you use the features the frameworks supplies. These are documented in this section and a comprehensive example is provided by the demo project.</p> <p>The following diagram visualizes how the framework's modular components fit together, each feature is described in detail below.</p> <p></p> <p>The StatefulService.h class is responsible for managing state. It has an API which allows other code to update or respond to updates in the state it manages. You can define a data class to hold state, then build a StatefulService class to manage it. After that you may attach HTTP endpoints, WebSockets or MQTT topics to the StatefulService instance to provide commonly required features.</p> <p>Here is a simple example of a state class and a StatefulService to manage it:</p> <pre><code>class LightState {\n public:\n  bool on = false;\n  uint8_t brightness = 255;\n};\n\nclass LightStateService : public StatefulService&lt;LightState&gt; {\n};\n</code></pre>"},{"location":"customproject/#update-handler","title":"Update Handler","text":"<p>You may listen for changes to state by registering an update handler callback. It is possible to remove an update handler later if required.</p> <pre><code>// register an update handler\nupdate_handler_id_t myUpdateHandler = lightStateService.addUpdateHandler(\n  [&amp;](const String&amp; originId) {\n    Serial.print(\"The light's state has been updated by: \");\n    Serial.println(originId);\n  }\n);\n\n// remove the update handler\nlightStateService.removeUpdateHandler(myUpdateHandler);\n</code></pre> <p>An \"originId\" is passed to the update handler which may be used to identify the origin of an update. The default origin values the framework provides are:</p> Origin Description http An update sent over REST (HttpEndpoint) mqtt An update sent over MQTT (MqttEndpoint) websocketserver:{clientId} An update sent over WebSocket (WebSocketServer)"},{"location":"customproject/#hook-handler","title":"Hook Handler","text":"<p>Sometimes if can be desired to hook into every update of an state, even if the StateUpdateResult is <code>StateUpdateResult::UNCHANGED</code> and the update handler isn't called. In such cases you can use the hook handler. Similarly it can be removed later.</p> <pre><code>// register an update handler\nhook_handler_id_t myHookHandler = lightStateService.addHookHandler(\n  [&amp;](const String&amp; originId, StateUpdateResult &amp;result) {\n    Serial.printf(\"The light's state has been updated by: %s with result %d\\n\", originId, result);\n  }\n);\n\n// remove the update handler\nlightStateService.removeHookHandler(myHookHandler);\n</code></pre>"},{"location":"customproject/#read-update-state","title":"Read &amp; Update State","text":"<p>StatefulService exposes a read function which you may use to safely read the state. This function takes care of protecting against parallel access to the state in multi-core environments such as the ESP32.</p> <pre><code>lightStateService.read([&amp;](LightState&amp; state) {\n  digitalWrite(LED_PIN, state.on ? HIGH : LOW); // apply the state update to the LED_PIN\n});\n</code></pre> <p>StatefulService also exposes an update function which allows the caller to update the state with a callback. This function automatically calls the registered update handlers if the state has been changed. The example below changes the state of the light (turns it on) using the arbitrary origin \"timer\" and returns the \"CHANGED\" state update result, indicating that a change was made:</p> <pre><code>lightStateService.update([&amp;](LightState&amp; state) {\n   if (state.on) {\n    return StateUpdateResult::UNCHANGED; // lights were already on, return UNCHANGED\n  }\n  state.on = true;  // turn on the lights\n  return StateUpdateResult::CHANGED; // notify StatefulService by returning CHANGED\n}, \"timer\");\n</code></pre> <p>There are three possible return values for an update function which are as follows:</p> Origin Description StateUpdateResult::CHANGED The update changed the state, propagation should take place if required StateUpdateResult::UNCHANGED The state was unchanged, propagation should not take place StateUpdateResult::ERROR There was an error updating the state, propagation should not take place"},{"location":"customproject/#json-serialization","title":"JSON Serialization","text":"<p>When reading or updating state from an external source (HTTP, WebSockets, or MQTT for example) the state must be marshalled into a serializable form (JSON). SettingsService provides two callback patterns which facilitate this internally:</p> Callback Signature Purpose JsonStateReader void read(T&amp; settings, JsonObject&amp; root) Reading the state object into a JsonObject JsonStateUpdater StateUpdateResult update(JsonObject&amp; root, T&amp; settings) Updating the state from a JsonObject, returning the appropriate StateUpdateResult <p>The static functions below can be used to facilitate the serialization/deserialization of the light state:</p> <pre><code>class LightState {\n public:\n  bool on = false;\n  uint8_t brightness = 255;\n\n  static void read(LightState&amp; state, JsonObject&amp; root) {\n    root[\"on\"] = state.on;\n    root[\"brightness\"] = state.brightness;\n  }\n\n  static StateUpdateResult update(JsonObject&amp; root, LightState&amp; state) {\n    state.on = root[\"on\"] | false;\n    state.brightness = root[\"brightness\"] | 255;\n    return StateUpdateResult::CHANGED;\n  }\n};\n</code></pre> <p>For convenience, the StatefulService class provides overloads of its <code>update</code> and <code>read</code> functions which utilize these functions.</p> <p>Read the state to a JsonObject using a serializer:</p> <pre><code>JsonObject jsonObject = jsonDocument.to&lt;JsonObject&gt;();\nlightStateService-&gt;read(jsonObject, LightState::read);\n</code></pre> <p>Update the state from a JsonObject using a deserializer:</p> <pre><code>JsonObject jsonObject = jsonDocument.as&lt;JsonObject&gt;();\nlightStateService-&gt;update(jsonObject, LightState::update, \"timer\");\n</code></pre>"},{"location":"customproject/#http-restful-endpoint","title":"HTTP RESTful Endpoint","text":"<p>The framework provides an HttpEndpoint.h class which may be used to register GET and POST handlers to read and update the state over HTTP. You may construct an HttpEndpoint as a part of the StatefulService or separately if you prefer.</p> <p>The code below demonstrates how to extend the LightStateService class to provide an endpoint:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(PsychicHttpServer* server, SecurityManager *securityManager) :\n      _httpEndpoint(LightState::read, LightState::update, this, server, \"/rest/lightState\", securityManager,AuthenticationPredicates::IS_AUTHENTICATED) {\n  }\n\n  void begin(); {\n    _httpEndpoint.begin();\n  }\n\n private:\n  HttpEndpoint&lt;LightState&gt; _httpEndpoint;\n};\n</code></pre> <p>Endpoint security is provided by authentication predicates which are documented below. The SecurityManager and authentication predicate must be provided, even if no secure endpoint is required. The placeholder project shows how endpoints can be secured.</p> <p>To register the HTTP endpoints with the web server the function <code>_httpEndpoint.begin()</code> must be called in the custom StatefulService Class' own <code>void begin()</code> function.</p>"},{"location":"customproject/#file-system-persistence","title":"File System Persistence","text":"<p>FSPersistence.h allows you to save state to the filesystem. FSPersistence automatically writes changes to the file system when state is updated. This feature can be disabled by calling <code>disableUpdateHandler()</code> if manual control of persistence is required.</p> <p>The code below demonstrates how to extend the LightStateService class to provide persistence:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(FS* fs) :\n      _fsPersistence(LightState::read, LightState::update, this, fs, \"/config/lightState.json\") {\n  }\n\n private:\n  FSPersistence&lt;LightState&gt; _fsPersistence;\n};\n</code></pre>"},{"location":"customproject/#event-socket-endpoint","title":"Event Socket Endpoint","text":"<p>EventEndpoint.h wraps the Event Socket into an endpoint compatible with a stateful service. The client may subscribe and unsubscribe to this event to receive updates or push updates to the ESP32. The current state is synchronized upon subscription.</p> <p>The code below demonstrates how to extend the LightStateService class to provide an WebSocket:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(EventSocket *socket) :\n      _eventEndpoint(LightState::read, LightState::update, this, socket, \"led\") {}\n\n  void begin()\n  {\n    _eventEndpoint.begin();\n  }\n\n private:\n  EventEndpoint&lt;LightState&gt; _eventEndpoint;\n};\n</code></pre> <p>To register the event endpoint with the event socket the function <code>_eventEndpoint.begin()</code> must be called in the custom StatefulService Class' own <code>void begin()</code> function.</p> <p>Since all events run through one websocket connection it is not possible to use the securityManager to limit access to individual events. The security defaults to <code>AuthenticationPredicates::IS_AUTHENTICATED</code>.</p>"},{"location":"customproject/#websocket-server","title":"WebSocket Server","text":"<p>WebSocketServer.h allows you to read and update state over a WebSocket connection. WebSocketServer automatically pushes changes to all connected clients when state is updated.</p> <p>The code below demonstrates how to extend the LightStateService class to provide an WebSocket:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(PsychicHttpServer* server, SecurityManager *securityManager) :\n      _webSocket(LightState::read, LightState::update, this, server, \"/ws/lightState\", securityManager, AuthenticationPredicates::IS_AUTHENTICATED), {\n  }\n\n  void begin() {\n    _webSocketServer.begin();\n  }\n\n private:\n  WebSocketServer&lt;LightState&gt; _webSocketServer;\n};\n</code></pre> <p>WebSocket security is provided by authentication predicates which are documented below. The SecurityManager and authentication predicate must be provided, even if no secure endpoint is required. The placeholder project shows how endpoints can be secured.</p> <p>To register the WS endpoint with the web server the function <code>_webSocketServer.begin()</code> must be called in the custom StatefulService Class' own <code>void begin()</code> function.</p>"},{"location":"customproject/#mqtt-client","title":"MQTT Client","text":"<p>The framework includes an MQTT client which can be configured via the UI. MQTT requirements will differ from project to project so the framework exposes the client for you to use as you see fit. The framework does however provide a utility to interface StatefulService to a pair of pub/sub (state/set) topics. This utility can be used to synchronize state with software such as Home Assistant.</p> <p>MqttEndpoint.h allows you to publish and subscribe to synchronize state over a pair of MQTT topics. MqttEndpoint automatically pushes changes to the \"pub\" topic and reads updates from the \"sub\" topic.</p> <p>The code below demonstrates how to extend the LightStateService class to interface with MQTT:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(AsyncMqttClient* mqttClient) :\n      _mqttEndpoint(LightState::read,\n                  LightState::update,\n                  this,\n                  mqttClient,\n                  \"homeassistant/light/my_light/set\",\n                  \"homeassistant/light/my_light/state\") {\n  }\n\n private:\n  MqttEndpoint&lt;LightState&gt; _mqttEndpoint;\n};\n</code></pre> <p>You can re-configure the pub/sub topics at runtime as required:</p> <pre><code>_mqttEndpoint.configureBroker(\"homeassistant/light/desk_lamp/set\", \"homeassistant/light/desk_lamp/state\");\n</code></pre> <p>The demo project allows the user to modify the MQTT topics via the UI so they can be changed without re-flashing the firmware.</p>"},{"location":"customproject/#event-socket","title":"Event Socket","text":"<p>Beside RESTful HTTP Endpoints the Event Socket System provides a convenient communication path between the client and the ESP32. It uses a single WebSocket connection to synchronize state and to push realtime data to the client. The client needs to subscribe to the topics he is interested. Only clients who have an active subscription will receive data. Every authenticated client may make use of this system as the security settings are set to <code>AuthenticationPredicates::IS_AUTHENTICATED</code>.</p>"},{"location":"customproject/#message-format","title":"Message Format","text":"<p>The event messages exchanged between the ESP32 and its clients consists of an \"event\" head and the \"data\" payload. For the LightState example a message looks like this in JSON representation:</p> <pre><code>{\n  \"event\": \"led\",\n  \"data\": {\n    \"led_on\": true\n  }\n}\n</code></pre> <p>To save on bandwidth the event message is encoded as binary MessagePack instead of a JSON.</p> <p>To subscribe the client has to send the following message (as MessagePack):</p> <pre><code>{\n  \"event\": \"subscribe\",\n  \"data\": \"analytics\"\n}\n</code></pre>"},{"location":"customproject/#emit-an-event","title":"Emit an Event","text":"<p>The Event Socket provides an <code>emitEvent()</code> function to push data to all subscribed clients. This is used by various esp32sveltekit classes to push real time data to the client. First an event must be registered with the Event Socket by calling <code>_socket.registerEvent(\"CustomEvent\");</code>. Only then clients may subscribe to this custom event and you're entitled to emit event data:</p> <pre><code>void emitEvent(String event, JsonObject &amp;jsonObject, const char *originId = \"\", bool onlyToSameOrigin = false);\n</code></pre> <p>The latter function allowing a selection of the recipient. If <code>onlyToSameOrigin = false</code> the payload is distributed to all subscribed clients, except the <code>originId</code>. If <code>onlyToSameOrigin = true</code> only the client with <code>originId</code> will receive the payload. This is used by the EventEndpoint to sync the initial state when a new client subscribes.</p>"},{"location":"customproject/#receive-an-event","title":"Receive an Event","text":"<p>A callback or lambda function can be registered to receive an ArduinoJSON object and the originId of the client sending the data:</p> <pre><code>_socket.onEvent(\"CostumEvent\",[&amp;](JsonObject &amp;root, int originId)\n{\n  bool ledState = root[\"led_on\"];\n});\n</code></pre>"},{"location":"customproject/#get-notified-on-subscriptions","title":"Get Notified on Subscriptions","text":"<p>Similarly a callback or lambda function may be registered to get notified when a client subscribes to an event:</p> <pre><code>_socket.onSubscribe(\"CostumEvent\",[&amp;](const String &amp;originId)\n{\n  Serial.println(\"New Client subscribed: \" + originId);\n});\n</code></pre> <p>The boolean parameter provided will always be <code>true</code>.</p>"},{"location":"customproject/#push-notifications-to-all-clients","title":"Push Notifications to All Clients","text":"<p>It is possibly to send push notifications to all clients by using the Event Socket. These will be displayed as toasts an the client side. Either directly call</p> <pre><code>esp32sveltekit.getNotificationService()-&gt;pushNotification(\"Pushed a message!\", PUSHINFO);\n</code></pre> <p>or keep a local pointer to the <code>EventSocket</code> instance. It is possible to send <code>PUSHINFO</code>, <code>PUSHWARNING</code>, <code>PUSHERROR</code> and <code>PUSHSUCCESS</code> events to all clients.</p>"},{"location":"customproject/#security-features","title":"Security features","text":"<p>The framework has security features to prevent unauthorized use of the device. This is driven by SecurityManager.h.</p> <p>On successful authentication, the /rest/signIn endpoint issues a JSON Web Token (JWT) which is then sent using Bearer Authentication. For this add an <code>Authorization</code>-Header to the request with the Content <code>Bearer {JWT-Secret}</code>. The framework come with built-in predicates for verifying a users access privileges. The built in AuthenticationPredicates can be found in SecurityManager.h and are as follows:</p> Predicate Description NONE_REQUIRED No authentication is required. IS_AUTHENTICATED Any authenticated principal is permitted. IS_ADMIN The authenticated principal must be an admin. <p>You can use the security manager to wrap any request handler function with an authentication predicate:</p> <pre><code>server-&gt;on(\"/rest/someService\", HTTP_GET,\n  _securityManager-&gt;wrapRequest(std::bind(&amp;SomeService::someService, this, std::placeholders::_1), AuthenticationPredicates::IS_AUTHENTICATED)\n);\n</code></pre> <p>In case of a websocket connection the JWT token is supplied as a search parameter in the URL when establishing the connection:</p> <pre><code>/ws/lightState?access_token={JWT Token}\n</code></pre>"},{"location":"customproject/#placeholder-substitution","title":"Placeholder substitution","text":"<p>Various settings support placeholder substitution, indicated by comments in factory_settings.ini. This can be particularly useful where settings need to be unique, such as the Access Point SSID or MQTT client id. Strings must be properly escaped in the ini-file. The following placeholders are supported:</p> Placeholder Substituted value #{platform} The microcontroller platform, e.g. \"esp32\" or \"esp32c3\" #{unique_id} A unique identifier derived from the MAC address, e.g. \"0b0a859d6816\" #{random} A random number encoded as a hex string, e.g. \"55722f94\" <p>You may use SettingValue::format in your own code if you require the use of these placeholders. This is demonstrated in the demo project:</p> <pre><code>  static StateUpdateResult update(JsonObject&amp; root, LightMqttSettings&amp; settings) {\n    settings.mqttPath = root[\"mqtt_path\"] | SettingValue::format(\"homeassistant/light/#{unique_id}\");\n    settings.name = root[\"name\"] | SettingValue::format(\"light-#{unique_id}\");\n    settings.uniqueId = root[\"unique_id\"] | SettingValue::format(\"light-#{unique_id}\");\n    return StateUpdateResult::CHANGED;\n  }\n</code></pre>"},{"location":"customproject/#accessing-settings-and-services","title":"Accessing settings and services","text":"<p>The framework supplies access to various features via getter functions:</p> SettingsService Description getFS() The filesystem used by the framework getSecurityManager() The security manager - detailed above getSecuritySettingsService() Configures the users and other security settings getWiFiSettingsService() Configures and manages the WiFi network connection getAPSettingsService() Configures and manages the Access Point getNTPSettingsService() Configures and manages the network time getMqttSettingsService() Configures and manages the MQTT connection getMqttClient() Provides direct access to the MQTT client instance getNotificationEvents() Lets you send push notifications to all clients getSleepService() Send the ESP32 into deep sleep getBatteryService() Update battery information on the client <p>The core features use the StatefulService.h class and therefore you can change settings or observe changes to settings through the read/update API.</p> <p>Inspect the current WiFi settings:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;read([&amp;](WiFiSettings&amp; wifiSettings) {\n  Serial.print(\"The ssid is:\");\n  Serial.println(wifiSettings.ssid);\n});\n</code></pre> <p>Configure the WiFi SSID and password manually:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;update([&amp;](WiFiSettings&amp; wifiSettings) {\n  wifiSettings.ssid = \"MyNetworkSSID\";\n  wifiSettings.password = \"MySuperSecretPassword\";\n  return StateUpdateResult::CHANGED;\n}, \"myapp\");\n</code></pre> <p>Observe changes to the WiFiSettings:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;addUpdateHandler(\n  [&amp;](const String&amp; originId) {\n    Serial.println(\"The WiFi Settings were updated!\");\n  }\n);\n</code></pre>"},{"location":"customproject/#other-functions-provided","title":"Other functions provided","text":""},{"location":"customproject/#mdns-instance-name","title":"MDNS Instance Name","text":"<p>ESP32 SvelteKit uses mDNS / Bonjour to advertise its services into the local network. You can set the mDNS instance name property by calling</p> <pre><code>esp32sveltekit.setMDNSAppName(\"ESP32 SvelteKit Demo App\");\n</code></pre> <p>making the entry a little bit more verbose. This must be called before <code>esp32sveltekit.begin();</code>. If you want to advertise further services just include <code>#include &lt;ESPmNDS.h&gt;</code> and use <code>MDNS.addService()</code> regularly.</p>"},{"location":"customproject/#factory-reset","title":"Factory Reset","text":"<p>A factory reset can not only be evoked from the API, but also by calling</p> <pre><code>esp32sveltekit.factoryReset();\n</code></pre> <p>from your code. This will erase the complete settings folder, wiping out all settings. This can be a last fall back mode if somebody has forgotten his credentials.</p>"},{"location":"customproject/#recovery-mode","title":"Recovery Mode","text":"<p>There is also a recovery mode present which will force the creation of an access point. By calling</p> <pre><code>esp32sveltekit.recoveryMode();\n</code></pre> <p>will force a start of the AP regardless of the AP settings. It will not change the the AP settings. To exit the recovery mode restart the device or change the AP settings in the UI.</p>"},{"location":"customproject/#power-down-with-deep-sleep","title":"Power Down with Deep Sleep","text":"<p>This API service can place the ESP32 in the lowest power deep sleep mode consuming only a few \u00b5A. It uses the EXT1 wakeup source, so the ESP32 can be woken up with a button or from a peripherals interrupt. Consult the ESP-IDF Api Reference which GPIOs can be used for this. The RTC will also be powered down, so an external pull-up or pull-down resistor is required. It is not possible to persist variable state through the deep sleep. To optimize the deep sleep power consumption it is advisable to use the callback function to put pins with external pull-up's or pull-down's in a special isolated state to prevent current leakage. Please consult the ESP-IDF Api Reference for this.</p> <p>The settings wakeup pin definition and the signal polarity need to be defined in factory_settings.ini:</p> <pre><code>; Deep Sleep Configuration\n-D WAKEUP_PIN_NUMBER=38 ; pin number to wake up the ESP\n-D WAKEUP_SIGNAL=0 ; 1 for wakeup on HIGH, 0 for wakeup on LOW\n</code></pre> <p>A callback function can be attached and triggers when the ESP32 is requested to go into deep sleep. This allows you to safely deal with the power down event. Like persisting software state by writing to the flash, tiding up or notify a remote server about the immanent disappearance.</p> <pre><code>esp32sveltekit.getSleepService()-&gt;attachOnSleepCallback();\n</code></pre> <p>Also the code can initiate the power down deep sleep sequence by calling:</p> <pre><code>esp32sveltekit.getSleepService()-&gt;sleepNow();\n</code></pre>"},{"location":"customproject/#battery-state-of-charge","title":"Battery State of Charge","text":"<p>A small helper class let's you update the battery icon in the status bar. This is useful if you have a battery operated IoT device. It must be enabled in features.ini. It uses the Event Socket and exposes two functions that can be used to update the clients.</p> <pre><code>esp32sveltekit.getBatteryService()-&gt;updateSOC(float stateOfCharge); // update state of charge in percent (0 - 100%)\nesp32sveltekit.getBatteryService()-&gt;setCharging(boolean isCharging); // notify the client that the device is charging\n</code></pre>"},{"location":"customproject/#custom-features","title":"Custom Features","text":"<p>You may use the compile time feature service also to enable or disable custom features at runtime and thus control the frontend. A custom feature can only be added during initializing the ESP32 and ESP32-SvelteKit. A feature can't be updated on runtime once it is set.</p> <pre><code>esp32sveltekit.getFeatureService()-&gt;addFeature(\"custom_feature\", true); // or false to disable it\n</code></pre>"},{"location":"customproject/#ota-firmware-updates","title":"OTA Firmware Updates","text":"<p>ESP32-SvelteKit offers two different ways to roll out firmware updates to field devices. If the frontend should be updated as well it is necessary to embed it into the firmware binary by activating <code>-D EMBED_WWW</code>.</p>"},{"location":"customproject/#firmware-upload","title":"Firmware Upload","text":"<p>Enabling <code>FT_UPLOAD_FIRMWARE=1</code> in features.ini creates a REST endpoint that one can post a firmware binary to. The frontend has a file drop zone to upload a new firmware binary from the browser.</p>"},{"location":"customproject/#firmware-download-from-update-server","title":"Firmware Download from Update Server","text":"<p>By enabling <code>FT_DOWNLOAD_FIRMWARE=1</code> in features.ini one can POST a link to a firmware binary which is downloaded for the OTA process. This feature requires SSL and is thus dependent on <code>FT_NTP=1</code>. The Frontend contains an implementation which uses GitHub's Releases section as the update server. By specifying a firmware version in platformio.ini one can make use of semantic versioning to determine the correct firmware:</p> <pre><code>    -D BUILD_TARGET=\"$PIOENV\"\n    -D APP_NAME=\\\"ESP32-Sveltekit\\\" ; Must only contain characters from [a-zA-Z0-9-_] as this is converted into a filename\n    -D APP_VERSION=\\\"0.3.0\\\" ; semver compatible version string\n</code></pre> <p>A build script copies the firmware binary files for all build environment to <code>build/firmware</code>. It renames them into <code>{APP_NAME}_{$PIOENV}_{APP_VERSION}.bin</code>. It also creates a MD5 checksum file for verification during the OTA process. These files can be used as attachment on the GitHub release pages.</p> <p>Info</p> <p>This feature could be unstable on single-core members of the ESP32 family.</p>"},{"location":"customproject/#custom-update-server","title":"Custom Update Server","text":"<p>If Github is not desired as the update server this can be easily modified to any other custom server. The REST API will accept any valid HTTPS-Link. However, SSL is mandatory and may require a different Root CA Certificate then Github to validate correctly. Follow the instructions here how to change the SSL CA Certificate.</p> <p>If you use a custom update server you must also adapt the frontend code to suit your needs.</p>"},{"location":"customui/","title":"RESTful API","text":"<p>The back end exposes a number of API endpoints which are referenced in the table below.</p> Method Request URL Authentication POST JSON Body Info GET /rest/features <code>NONE_REQUIRED</code> none Tells the client which features of the UI should be use GET /rest/mqttStatus <code>IS_AUTHENTICATED</code> none Current MQTT connection status GET /rest/mqttSettings <code>IS_ADMIN</code> none Currently used MQTT settings POST /rest/mqttSettings <code>IS_ADMIN</code> <code>{\"enabled\":false,\"uri\":\"mqtt://192.168.1.12:1883\",\"username\":\"\",\"password\":\"\",\"client_id\":\"esp32-f412fa4495f8\",\"keep_alive\":120,\"clean_session\":true}</code> Update MQTT settings with new parameters GET /rest/ntpStatus <code>IS_AUTHENTICATED</code> none Current NTP connection status GET /rest/ntpSettings <code>IS_ADMIN</code> none Current NTP settings POST /rest/ntpSettings <code>IS_ADMIN</code> <code>{\"enabled\": true,\"server\": \"time.google.com\",\"tz_label\": \"Europe/London\",\"tz_format\": \"GMT0BST,M3.5.0/1,M10.5.0\"}</code> Update the NTP settings GET /rest/apStatus <code>IS_AUTHENTICATED</code> none Current AP status and client information GET /rest/apSettings <code>IS_ADMIN</code> none Current AP settings POST /rest/apSettings <code>IS_ADMIN</code> <code>{\"provision_mode\": 1,\"ssid\": \"ESP32-SvelteKit-e89f6d20372c\",\"password\": \"esp-sveltekit\",\"channel\": 1,\"ssid_hidden\": false,\"max_clients\": 4,\"local_ip\": \"192.168.4.1\",\"gateway_ip\": \"192.168.4.1\",\"subnet_mask\": \"255.255.255.0\"}</code> Update AP settings GET /rest/wifiStatus <code>IS_AUTHENTICATED</code> none Current status of the wifi client connection GET /rest/scanNetworks <code>IS_ADMIN</code> none Async Scan for Networks in Range GET /rest/listNetworks <code>IS_ADMIN</code> none List networks in range after successful scanning. Otherwise triggers scanning. GET /rest/wifiSettings <code>IS_ADMIN</code> none Current WiFi settings POST /rest/wifiSettings <code>IS_ADMIN</code> <code>{\"hostname\":\"esp32-f412fa4495f8\",\"priority_RSSI\":true,\"wifi_networks\":[{\"ssid\":\"YourSSID\",\"password\":\"YourPassword\",\"static_ip_config\":false}]}</code> Update WiFi settings and credentials GET /rest/systemStatus <code>IS_AUTHENTICATED</code> none Get system information about the ESP. POST /rest/restart <code>IS_ADMIN</code> none Restart the ESP32 POST /rest/factoryReset <code>IS_ADMIN</code> none Reset the ESP32 and all settings to their default values POST /rest/uploadFirmware <code>IS_ADMIN</code> none File upload of firmware.bin POST /rest/signIn <code>NONE_REQUIRED</code> <code>{\"password\": \"admin\",\"username\": \"admin\"}</code> Signs a user in and returns access token GET /rest/securitySettings <code>IS_ADMIN</code> none retrieves all user information and roles POST /rest/securitySettings <code>IS_ADMIN</code> <code>{\"jwt_secret\": \"734cb5bb-5597b722\", \"users\": [{\"username\": \"admin\", \"password\": \"admin\", \"admin\": true}, {\"username\": \"guest\", \"password\": \"guest\", \"admin\": false, }]}</code> retrieves all user information and roles GET /rest/verifyAuthorization <code>NONE_REQUIRED</code> none Verifies the content of the auth bearer token GET /rest/generateToken?username={username} <code>IS_ADMIN</code> <code>{\"token\": \"734cb5bb-5597b722\"}</code> Generates a new JWT token for the user from username POST /rest/sleep <code>IS_AUTHENTICATED</code> none Puts the device in deep sleep mode POST /rest/downloadUpdate <code>IS_ADMIN</code> <code>{\"download_url\": \"https://github.com/theelims/ESP32-sveltekit/releases/download/v0.1.0/firmware_esp32s3.bin\"}</code> Download link for OTA. This requires a valid SSL certificate and will follow redirects."},{"location":"esp32sveltekit/","title":"Getting Started","text":""},{"location":"esp32sveltekit/#prerequisites","title":"Prerequisites","text":"<p>This project has quite a complicated build chain to prepare the frontend code for the ESP32. You will need to install some tools to make this all work, starting with a powerful code editor.</p>"},{"location":"esp32sveltekit/#softwares-to-install","title":"Softwares to Install","text":"<p>Please install the following software, if you haven't already:</p> <ul> <li>VSCode - IDE for development</li> <li>Node.js - For building the interface with npm</li> </ul>"},{"location":"esp32sveltekit/#vscode-plugins-and-setups","title":"VSCode Plugins and Setups","text":"<p>Please install the following mandatory VSCode Plugins:</p> <ul> <li>PlatformIO - Embedded development platform</li> <li>Prettier - Automated code formatter</li> <li>Svelte for VS Code - Makes working with Svelte much easier</li> <li>Svelte Intellisense - Another Svelte tool</li> <li>Tailwind CSS Intellisense - Makes working with Tailwind CSS much easier</li> <li>Prettier plugin for Tailwind CSS - Automatically sorts the Tailwind classes into their recommended order</li> </ul> <p>Lastly, if you want to make use of Materials for MkDocs as your documentation engine, install Material for MkDocs by typing the following into the VSCode terminal:</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>Tip</p> <p>You might need to run this as administrator, if you getting an error message.</p>"},{"location":"esp32sveltekit/#project-structure","title":"Project Structure","text":"Resource Description .github/ Github CI pipeline to deploy MkDocs to gh-pages docs/ MkDocs documentation files interface/ SvelteKit based front end lib/framework/ C++ back end for the ESP32 device src/ The main.cpp and demo project to get you started scripts/ Scripts that build the interface as part of the platformio build platformio.ini PlatformIO project configuration file mkdocs.yaml MkDocs project configuration file"},{"location":"esp32sveltekit/#setting-up-platformio","title":"Setting up PlatformIO","text":""},{"location":"esp32sveltekit/#setup-build-target","title":"Setup Build Target","text":"<p>Do not use the PlatformIO UI for editing platformio.ini</p> <p>It is tempting to use the PlatformIO user interface to add dependencies or parameters to platformio.ini. However, doing so will remove all \"irrelevant\" information like comments from the file. Please edit the file directly in the editor.</p> <p>platformio.ini is the central file controlling the whole build process. It comes pre-configure with a few boards which have different ESP32 chips. It needs to be adapted to the board you want to program.</p> <pre><code>[platformio]\n...\ndefault_envs = esp32-s3-devkitc-1\n...\n\n[env:adafruit_feather_esp32_v2]\nboard = adafruit_feather_esp32_v2\nboard_build.mcu = esp32\n\n[env:lolin_c3_mini]\nboard = lolin_c3_mini\nboard_build.mcu = esp32c3\n\n[env:esp32-s3-devkitc-1]\nboard = esp32-s3-devkitc-1\nboard_build.mcu = esp32s3\n</code></pre> <p>If your board is not listed in the platformio.ini you may look in the official board list for supported boards and add their information accordingly. Either delete the obsolete <code>[env:...]</code> sections, or change your board as <code>default_envs = ...</code>.</p> <p>Default setup is for an ESP32-S3-DevKitC/M board</p> <p>The projects platformio.ini defaults for an ESP32-S3-DevKitC/M board by Espressif connected to the UART USB port. If you use an other board and the projects shows an undesired behavior it is likely that some parts do not match with pin definitions.</p>"},{"location":"esp32sveltekit/#build-upload-process","title":"Build &amp; Upload Process","text":"<p>After you've changed platformio.ini to suit your board you can upload the sample code to your board. This will download all ESP32 libraries and execute <code>node install</code> to install all node packages as well. Select your board's environment under the PlatformIO tab and hit <code>Upload and Monitor</code>.</p> <p></p> <p>The first build process will take a while. After a couple of minutes you can see the ESP32 outputting information on the terminal. Some of the python scripts might need to install additional packages. In that case the first build process will fail. Just run it a second time.</p> <p>Use several terminals in parallel</p> <p>VSCode allows you to have more then one terminal running at the same time. You can dedicate one terminal to the serial monitor, while having the development server running in an other terminal.</p>"},{"location":"esp32sveltekit/#setting-up-sveltekit","title":"Setting up SvelteKit","text":""},{"location":"esp32sveltekit/#setup-proxy-for-development","title":"Setup Proxy for Development","text":"<p>To ease the frontend development you can deploy the back end code on an ESP32 board and pass the websocket and REST API calls through the development server's proxy. The vite.config.ts file defines the location of the services which the development server will proxy. This is defined by the \"target\" property, which will need to be changed to the the IP address or hostname of the device running the firmware. Change this for both, \"http://\" and \"ws://\".</p> <pre><code>proxy: {\n    // Proxying REST: http://localhost:5173/rest/bar -&gt; http://192.168.1.83/rest/bar\n    '/rest': {\n    target: 'http://192.168.1.83',\n    changeOrigin: true,\n    },\n    // Proxying websockets ws://localhost:5173/ws -&gt; ws://192.168.1.83/ws\n    '/ws': {\n    target: 'ws://192.168.1.83',\n    changeOrigin: true,\n    ws: true,\n    },\n},\n</code></pre> <p>Tip</p> <p>You must restart the development server for changes of the proxy location to come into effect.</p>"},{"location":"esp32sveltekit/#development-server","title":"Development Server","text":"<p>The interface comes with Vite as a development server. It allows hot module reloading reflecting code changes to the front end instantly in your browser. Open a new terminal session and execute the following commands:</p> <pre><code>cd interface\nnpm run dev\n</code></pre> <p>Follow the link to access the front end in your browser.</p>"},{"location":"esp32sveltekit/#setup-material-for-mkdocs","title":"Setup Material for mkdocs","text":"<p>Material for MkDocs allows you to create great technical documentation pages just from markup. If you don't want to use it just delete the <code>.github</code> and <code>docs</code> folder, as well as <code>mkdocs.yaml</code>.</p> <p>Otherwise initiate the github CI pipeline by committing and pushing to your repository once. This triggers the automatic build. After a few minutes a new branch <code>gh-pages</code> containing the static website with your documentation should appear. To deploy it go to your github repository go under settings and complete the following steps. </p>"},{"location":"esp32sveltekit/#development-server_1","title":"Development Server","text":"<p>MkDocs comes with a build-in development server which supports hot reload as well. Open a new terminal session in VSCode and type</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"factorysettings/","title":"Factory Settings","text":"<p>The factory default settings, either after flashing the binary to the board for the first time or after applying from the System Status menu are managed in factory_setting.ini.</p>"},{"location":"factorysettings/#access-point","title":"Access Point","text":"<p>By default, the Access Point offers a network with: </p> <ul> <li>SSID: ESP32-#{unique_id} </li> <li>password: esp-sveltekit </li> <li>ip-address: 192.168.4.1</li> </ul> <p>After logging in as admin to the board, just set the WiFi credendials for connecting to your WiFi. When connected successfully, the Access Point will be stopped (if not configured otherwise). </p>"},{"location":"factorysettings/#users","title":"Users","text":"<p>By default, a guest and an admin user are defined.  The credentials are simply:</p> <ul> <li>guest/guest</li> <li>admin/admin</li> </ul>"},{"location":"platformio/","title":"Components","text":"<p>The project includes a number of components to create the user interface. Even though DaisyUI has a huge set of components, it is often beneficial to recreate them as a Svelte component. This offers a much better integration into the Svelte way of doing things, is less troublesome with animations and results in a overall better user experience.</p>"},{"location":"platformio/#collapsible","title":"Collapsible","text":"<p>A collapsible container to hide / show content by clicking on the arrow button.</p> <pre><code>import Collapsible from \"$lib/components/Collapsible.svelte\";\n</code></pre> <p>It exports a closed / open state with <code>export open</code> which you can use to determine the mounting behavior of the component.</p>"},{"location":"platformio/#slots","title":"Slots","text":"<p>The component has two slots. A named slot <code>title</code> for the collapsible title and the main slot for the content that can be hidden or shown.</p> <pre><code>&lt;Collapsible open={false} class=\"shadow-lg\" on:closed={doSomething}&gt;\n  &lt;span slot=\"title\"&gt;Title&lt;/span&gt;\n  ...\n&lt;/Collapsible&gt;\n</code></pre> <p>The <code>class</code> attribute may be used as normal to style the container. By default there is no special styling like background or shadows to accentuate the container element.</p>"},{"location":"platformio/#events","title":"Events","text":"<p>The collapsible component dispatches two events. <code>on:closed</code> when the collapsible is closed and <code>on:opened</code> when it is opened. You can bind to them as to any other event.</p>"},{"location":"platformio/#inputpassword","title":"InputPassword","text":"<p>This is an input field specifically for passwords. It comes with an \"eye\"-button on the right border to toggle the visibility of the password. It natively blends into the style from DaisyUI.</p> <pre><code>import InputPassword from \"$lib/components/InputPassword.svelte\";\n</code></pre> <p>You may use it like any other form element:</p> <pre><code>&lt;InputPassword id=\"pwd\" bind:value={password} /&gt;\n</code></pre>"},{"location":"platformio/#rssiindicator","title":"RSSIIndicator","text":"<p>This shows the popular WiFi strength indicator icon with differently highlighted circles depending on the received signal strength (RSSI) of the WiFi signal. In addition it can display the signal strength in raw \"dBm\" as an indicator badge.</p> <pre><code>import RssiIndicator from \"$lib/components/RSSIIndicator.svelte\";\n</code></pre> <p>Just use and style as you please. It doesn't have any slots or events.</p> <pre><code>&lt;RssiIndicator showDBm={true} rssi_dbm={-85} class=\"text-base-content h-10 w-10\" /&gt;\n</code></pre> <p>Two exports control the behavior of the component. <code>rssi_dbm</code> accepts a negative number of the raw RSSI in dBm and is used to determine how many circles of reception should be shown. An optional boolean <code>showDBm</code> (defaults to <code>false</code>) shows the indicator badge with the dBm value.</p>"},{"location":"platformio/#settings-card","title":"Settings Card","text":"<p>A Settings Card is in many ways similar to a collapsible. However, it is styled and is the main element of many settings menus. It also accepts an icon in a dedicate slot and unlike collapsible has no events.</p> <pre><code>import SettingsCard from \"$lib/components/SettingsCard.svelte\";\n</code></pre>"},{"location":"platformio/#slots_1","title":"Slots","text":"<p>Three slots are available. Besides the main slot for the content there is a named slot for the <code>title</code> and s second one for the <code>icon</code>.</p> <pre><code>&lt;SettingsCard collapsible={true} open={false}&gt;\n    &lt;Icon slot=\"icon\" class=\"lex-shrink-0 mr-2 h-6 w-6 self-end\" /&gt;\n    &lt;span slot=\"title\"&gt;Title&lt;/span&gt;\n    ...\n&lt;/SettingsCard&gt;\n</code></pre> <p>The component exports two properties to determine its behavior. <code>collapsible</code> is a boolean describing wether the component should behave like a collapsible in the first place. <code>open</code> is a boolean as well and if set true shows the full content of the body on mount.</p>"},{"location":"platformio/#spinner","title":"Spinner","text":"<p>A small component showing an animated spinner which can be used while waiting for data.</p> <pre><code>import Spinner from \"$lib/components/Spinner.svelte\";\n</code></pre> <p>No slots, no events, no properties. Just use <code>&lt;Spinner/&gt;</code> whenever something is loading.</p>"},{"location":"platformio/#toast-notifications","title":"Toast Notifications","text":"<p>Toast notifications are implemented as a writable store and are easy to use from any script section. They are an easy way to feedback to the user. To use them just import the notifications store</p> <pre><code>import { notifications } from \"$lib/components/toasts/notifications\";\n</code></pre> <p>and call one of the 4 toast methods:</p> Method Description <code>notification.error(msg:string, timeout:number)</code>  Shows an error message <code>notification.warning(msg:string, timeout:number)</code>  Shows a warning message <code>notification.info(msg:string, timeout:number)</code>  Shows an info message <code>notification.success(msg:string, timeout:number)</code>  Shows as success message <p>Each method takes an <code>msg</code>-string as an argument, which will be shown as the message body. It accepts HTML to enrich your toasts, if you should desire to do so. The <code>timeout</code> argument specifies how many milliseconds the toast notification shall be shown to the user.</p>"},{"location":"platformio/#github-update-dialog","title":"Github Update Dialog","text":"<p>This is a modal showing the update progress, possible error messages and makes a full page refresh 5 seconds after the OTA was successful.</p>"},{"location":"platformio/#update-indicator","title":"Update Indicator","text":"<p>The update indicator is a small widget shown in the upper right corner of the status bar. It indicates the availability of a newer firmware release then the current one. Upon pressing the icon it will automatically update the firmware to the latest release. By default this works through the Github Latest Release API. This must be customized should you use a different update server. Have a look at the source file to see what portions to update.</p>"},{"location":"platformio/#info-dialog","title":"Info Dialog","text":"<p>Shows a modal on the UI which must be deliberately dismissed. It features a <code>title</code> and a <code>message</code> property. The dismiss button can be customized via the <code>dismiss</code> property with a label and an icon. <code>onDismiss</code> call back must close the modal and can be used to do something when closing the info dialog.</p> <pre><code>import InfoDialog from \"$lib/components/InfoDialog.svelte\";\n\nopenModal(InfoDialog, {\n  title: 'You have a new Info',\n  message:\n    'Something really important happened that justifies showing you a modal which must be clicked away.',\n  dismiss: { label: 'OK', icon: Check },\n  onDismiss: () =&gt; closeModal();\n});\n</code></pre> <p>This modal is based on svelte-modals where you can find further information.</p>"},{"location":"platformio/#confirm-dialog","title":"Confirm Dialog","text":"<p>Shows a confirm modal on the UI which must be confirmed to proceed, or can be canceled. It features a <code>title</code> and a <code>message</code> property. The <code>confirm</code> and <code>cancel</code> buttons can be customized via the <code>labels</code> property with a label and an icon. <code>onConfirm</code> call back must close the modal and can be used to trigger further actions.</p> <pre><code>import ConfirmDialog from \"$lib/components/ConfirmDialog.svelte\";\n\nopenModal(ConfirmDialog, {\n  title: \"Confirm what you are doing\",\n  message: \"Are you sure you want to proceed? This could break stuff!\",\n  labels: {\n    cancel: { label: \"Abort\", icon: Cancel },\n    confirm: { label: \"Confirm\", icon: Check },\n  },\n  onConfirm: () =&gt; closeModal(),\n});\n</code></pre> <p>This modal is based on svelte-modals where you can find further information.</p>"},{"location":"sveltekit/","title":"Getting Started with SvelteKit","text":"<p>SvelteKits unique approach makes it perfect suitable for constraint server. It builds very small files shipping only the minimum required amount of java script. This keeps the memory footprint low so that rich applications can be build with just the 4MB flash of many ESP32 chips.</p> <p>However, since SvelteKit is designed with server-side rendering first, there are some catches and pitfalls one must avoid. Especially as nearly all tutorials found on SvelteKit heavily make use of the combined front and back end features.</p>"},{"location":"sveltekit/#limitations-of-adapter-static","title":"Limitations of <code>adapter-static</code>","text":"<p>To build a website that can be served from an ESP32 <code>adapter-static</code> is used. This means no server functions can be used. The front end is build as a Single-Page Application (SPA) instead. However, SvelteKit will pre-render sites at build time, even if SSR and pre-rendering are disabled. This leads to some restrictions that must be taken into consideration:</p> <ul> <li> <p>You can't use any server-side logic like <code>+page.server.ts</code>, <code>+layout.server.ts</code> or <code>+server.ts</code> files in your project.</p> </li> <li> <p>The load function in <code>+page.ts</code> gets executed on the server and the client. If you try to access browser resources in the load function this will fail. Use a more traditional way like fetching the data in the <code>+page.svelte</code> with the <code>onMount(() =&gt; {})</code> callback.</p> </li> </ul>"},{"location":"sveltekit/#customizing-and-theming","title":"Customizing and Theming","text":""},{"location":"sveltekit/#changing-the-app-name","title":"Changing the App Name","text":"<p>+layout.ts bundles a few globally customizable properties like github repository, app name and copyright notice:</p> <pre><code>export const load = (async () =&gt; {\n    const result = await fetch('/rest/features');\n    const item = await result.json();\n    return {\n        features: item,\n        title: 'ESP32-SvelteKit',\n        github: 'theelims/ESP32-sveltekit',\n        copyright: '2024 theelims',\n        appName: 'ESP32 SvelteKit'\n    };\n}) satisfies LayoutLoad;\n</code></pre> <p>In menu.svelte there is additionally the possibility to add a discord invite, which is disabled by default.</p> <pre><code>const discord = { href: \".\", active: false };\n</code></pre> <p>There is also a manifest file which contains the app name to use when adding the app to a mobile device, so you may wish to also edit interface/static/manifest.json:</p> <pre><code>{\n  \"name\": \"ESP32 SvelteKit\",\n  \"icons\": [\n    {\n      \"src\": \"/favicon.png\",\n      \"sizes\": \"48x48 72x72 96x96 128x128 256x256\"\n    }\n  ],\n  \"start_url\": \"/\",\n  \"display\": \"fullscreen\",\n  \"orientation\": \"any\"\n}\n</code></pre>"},{"location":"sveltekit/#changing-the-app-icon-and-favicon","title":"Changing the App Icon and Favicon","text":"<p>You can replace the apps favicon which is located at interface/static/favicon.png with one of your preference. A 256 x 256 PNG is recommended for best compatibility.</p> <p>Also the Svelte Logo can be replaced with your own. It is located under interface/src/lib/assets/logo.png.</p>"},{"location":"sveltekit/#daisy-ui-themes","title":"Daisy UI Themes","text":"<p>The overall theme of the front end is defined by DaisyUI and can be easily changed according to their documentation. Either by selecting one of the standard themes of DaisyUI, or creating your own. By default the <code>corporate</code> and <code>business</code> for dark are defined in tailwind.config.cjs:</p> <pre><code>    daisyui: {\n        themes: ['corporate', 'business'],\n        darkTheme: 'business'\n    }\n</code></pre>"}]}